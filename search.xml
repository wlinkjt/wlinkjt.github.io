<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS基础（二）</title>
      <link href="/2022/10/05/freertos-ji-chu-er/"/>
      <url>/2022/10/05/freertos-ji-chu-er/</url>
      
        <content type="html"><![CDATA[<p>本篇主要对FreeRTOS的任务创建以及调度等进行源码分析</p><h1 id="1-FreeRTOS列表和列表项"><a href="#1-FreeRTOS列表和列表项" class="headerlink" title="1 FreeRTOS列表和列表项"></a>1 FreeRTOS列表和列表项</h1><p>想要搞清楚FreeRTOS的任务调度原理，首先需要了解其列表与列表项。因为FreeRTOS任务的状态变换都是通过列表来完成的。</p><h2 id="1-1-列表与列表项定义"><a href="#1-1-列表与列表项定义" class="headerlink" title="1.1 列表与列表项定义"></a>1.1 列表与列表项定义</h2><p>FreeRTOS的列表与列表项与数据结构的链表相似。在list.h文件中定义如下：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct xLIST{listFIRST_LIST_INTEGRITY_CHECK_VALUE  &lt;font color='green'&gt;//检测列表完整性，默认不开启&lt;/font&gt;volatile UBaseType_t uxNumberOfItems;     //列表项的数量ListItem_t * configLIST_VOLATILE pxIndex; //当前列表项索引号MiniListItem_t xListEnd;  //该列表中最后一个列表项listSECOND_LIST_INTEGRITY_CHECK_VALUE     //检测列表完整性，默认不开启} List_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体为FreeRTOS中列表项的定义，除去开头与结尾检测完整性的成员外，只包含3个成员变量，分别为列表项的数量，列表项索引号以及列表中最后一个列表项。<br>下面对列表项的结构体进行介绍。首先对完整的列表项定义进行介绍</p><pre class="line-numbers language-none"><code class="language-none">struct xLIST_ITEM{listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE    //完整性检测configLIST_VOLATILE TickType_t xItemValue;//当前索引值struct xLIST_ITEM * configLIST_VOLATILE pxNext;//下一个索引struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;//上一个索引void * pvOwner;//归属哪个任务struct xLIST * configLIST_VOLATILE pxContainer;//归属哪个列表listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE//完整性检测};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面为FreeRTOS中对列表项的完整定义，为保证内存的充分利用，FreeRTOS中还定义了迷你列表项，其定义如下</p><pre class="line-numbers language-none"><code class="language-none">struct xMINI_LIST_ITEM{listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE    //完整性检测configLIST_VOLATILE TickType_t xItemValue;          //当前索引值struct xLIST_ITEM * configLIST_VOLATILE pxNext;     //下一个索引值struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; //上一个索引值};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迷你列表项相对完整列表项省去了其归属的对象参数。</p><h2 id="1-2-列表与列表项函数"><a href="#1-2-列表与列表项函数" class="headerlink" title="1.2 列表与列表项函数"></a>1.2 列表与列表项函数</h2><p>列表与列表项的函数不多，主要包含列表与列表项的初始化、列表元素的插入、列表元素的末尾插入以及列表元素的删除，下面分别对其进行源码分析</p><h3 id="1-2-1-列表与列表项的初始化"><a href="#1-2-1-列表与列表项的初始化" class="headerlink" title="1.2.1 列表与列表项的初始化"></a>1.2.1 列表与列表项的初始化</h3><p>首先对列表的初始化进行分析，其源码如下</p><pre class="line-numbers language-none"><code class="language-none">void vListInitialise( List_t * const pxList ){pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );          //列表当前索引指向列表尾项pxList-&gt;xListEnd.xItemValue = portMAX_DELAY;                          //列表尾项赋值初始化pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );  //列表后一个元素指向自己pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); //列表前一个元素指向自己pxList-&gt;uxNumberOfItems = ( UBaseType_t ) 0U;                         //列表项个数为0listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );//完整性检测listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对列表的初始化函数可以看到，主要对列表尾项进行赋值以及最后将列表项的个数进行了初始化。<br>下面对列表项的初始化函数进行分析。源代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vListInitialiseItem( ListItem_t * const pxItem ){pxItem-&gt;pxContainer = NULL;  //列表归属为空listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem ); //完整性检测listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表项的初始化相对比较简单，只是将其归属的列表设置为空。</p><h3 id="1-2-2-列表项插入"><a href="#1-2-2-列表项插入" class="headerlink" title="1.2.2 列表项插入"></a>1.2.2 列表项插入</h3><p>列表项的插入是通过操作列表来进行的。函数原型如下：</p><pre class="line-numbers language-none"><code class="language-none">void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ){    ListItem_t *pxIterator;    const TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;//获取插入列表项的值listTEST_LIST_INTEGRITY( pxList );             //完整性检测listTEST_LIST_ITEM_INTEGRITY( pxNewListItem ); //完整性检测if( xValueOfInsertion == portMAX_DELAY )       //列表项值为最大值 {pxIterator = pxList-&gt;xListEnd.pxPrevious;}else{for( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;pxIterator= pxIterator-&gt;pxNext ) //升序遍历，直到找到小于插入列表项的值的最大值{}}pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;//插入列表项pxNewListItem-&gt;pxPrevious = pxIterator;pxIterator-&gt;pxNext = pxNewListItem;    //插入列表项pxNewListItem-&gt;pxContainer = pxList;   //定义所属列表( pxList-&gt;uxNumberOfItems )++;         //列表项个数加一}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从列表项插入函数来看，在FreeRTOS列表结构中，列表项是按列表项值进行升序排列的。</p><h3 id="1-2-3-列表项末尾插入"><a href="#1-2-3-列表项末尾插入" class="headerlink" title="1.2.3 列表项末尾插入"></a>1.2.3 列表项末尾插入</h3><p>列表项末尾插入相对较为简单，插入列表项只需放到被插入列表当前指向列表项的前面一个即可。具体源码如下：</p><pre class="line-numbers language-none"><code class="language-none">void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ){    ListItem_t * const pxIndex = pxList-&gt;pxIndex;  //获取被插入列表当前索引值listTEST_LIST_INTEGRITY( pxList );             //完整性检测listTEST_LIST_ITEM_INTEGRITY( pxNewListItem ); //完整性检测pxNewListItem-&gt;pxNext = pxIndex;               pxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious;//插入列表项mtCOVERAGE_TEST_DELAY();pxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem;pxIndex-&gt;pxPrevious = pxNewListItem;           //插入列表项pxNewListItem-&gt;pxContainer = pxList;           //定义所属列表( pxList-&gt;uxNumberOfItems )++;                 //列表项个数加一}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-4-列表项删除"><a href="#1-2-4-列表项删除" class="headerlink" title="1.2.4 列表项删除"></a>1.2.4 列表项删除</h3><p>列表项的删除通过将列表项移除所属列表，其源码如下：</p><pre class="line-numbers language-none"><code class="language-none">UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ){    List_t * const pxList = pxItemToRemove-&gt;pxContainer; //获取删除列表项所属的列表pxItemToRemove-&gt;pxNext-&gt;pxPrevious = pxItemToRemove-&gt;pxPrevious;pxItemToRemove-&gt;pxPrevious-&gt;pxNext = pxItemToRemove-&gt;pxNext;    //删除列表项mtCOVERAGE_TEST_DELAY();if( pxList-&gt;pxIndex == pxItemToRemove )           //如果当前列表索引值是当前被删除的列表项{pxList-&gt;pxIndex = pxItemToRemove-&gt;pxPrevious; //列表索引值前移}else                                              //不做处理{mtCOVERAGE_TEST_MARKER();}pxItemToRemove-&gt;pxContainer = NULL;               //所属列表为空( pxList-&gt;uxNumberOfItems )--;                    //原列表中列表项个数减一return pxList-&gt;uxNumberOfItems;                   //返回列表中还存在的列表项数量}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对列表以及列表项函数进行分析，可以看到FreeRTOS的列表与数据结构的链表操作一样。而FreeRTOS的任务调度就是通过操作列表以及列表项来实现的，下面对FreeRTOS的任务调度进行分析。</p><h1 id="2-FreeRTOS任务调度"><a href="#2-FreeRTOS任务调度" class="headerlink" title="2 FreeRTOS任务调度"></a>2 FreeRTOS任务调度</h1><p>上面我们以及对FreeRTOS的列表以及列表项的知识进行了详细的回顾以及学习，下面对FreeRTOS的任务调度进行分析。<br>在进行任务调度分析之前，首先需要了解任务控制块这个结构体，其定义如下：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct tskTaskControlBlock {volatile StackType_t*pxTopOfStack;  //任务堆栈栈顶    //使用MPU#if ( portUSING_MPU_WRAPPERS == 1 )xMPU_SETTINGSxMPUSettings;#endifListItem_txStateListItem;                      //任务状态列表ListItem_txEventListItem;   //任务事件列表UBaseType_tuxPriority;                      //任务优先级StackType_t*pxStack;                      //任务堆栈charpcTaskName[ configMAX_TASK_NAME_LEN ];//任务名    //栈向上生长，定义栈顶#if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )StackType_t*pxEndOfStack;#endif    //临界区栈深度#if ( portCRITICAL_NESTING_IN_TCB == 1 )UBaseType_tuxCriticalNesting;#endif    //调试追踪时，TCB与任务的数量#if ( configUSE_TRACE_FACILITY == 1 )UBaseType_tuxTCBNumber;UBaseType_tuxTaskNumber;#endif    //互斥信号量中，任务的基础优先级以及持有的信号量个数#if ( configUSE_MUTEXES == 1 )UBaseType_tuxBasePriority;UBaseType_tuxMutexesHeld;#endif    //#if ( configUSE_APPLICATION_TASK_TAG == 1 )TaskHookFunction_t pxTaskTag;#endif#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )void*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];#endif    //task运行的总时间#if( configGENERATE_RUN_TIME_STATS == 1 )uint32_tulRunTimeCounter;#endif    //#if ( configUSE_NEWLIB_REENTRANT == 1 )struct_reent xNewLib_reent;#endif#if( configUSE_TASK_NOTIFICATIONS == 1 )volatile uint32_t ulNotifiedValue;volatile uint8_t ucNotifyState;#endif#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) uint8_tucStaticallyAllocated; #endif#if( INCLUDE_xTaskAbortDelay == 1 )uint8_t ucDelayAborted;#endif#if( configUSE_POSIX_ERRNO == 1 )int iTaskErrno;#endif} tskTCB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZYNQ嵌入式开发（一）</title>
      <link href="/2022/04/01/zynq-qian-ru-shi-kai-fa-yi/"/>
      <url>/2022/04/01/zynq-qian-ru-shi-kai-fa-yi/</url>
      
        <content type="html"><![CDATA[<p>本篇主要对如何进行zynq嵌入式开发的流程进行介绍。开发环境为vivado 2018.3</p><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>zynq嵌入式开发流程如下图1，主要分为6步。对于初学者来说，首先需要掌握硬件环境搭建，也就是前4步。<br><img src="https://s1.ax1x.com/2022/07/17/j579Ag.png" alt="图1 zynq嵌入式开发流程"><br>下面以创建读写SD卡并通过串口发送消息为例进行流程讲解。</p><h1 id="硬件环境搭建"><a href="#硬件环境搭建" class="headerlink" title="硬件环境搭建"></a>硬件环境搭建</h1><p>首先打开vivado界面，选择create project，在创建好工程名后一路点击next，选择好自己芯片型号后，最后得到图2所示的界面。<br><img src="https://s1.ax1x.com/2022/07/16/j56SJS.md.png" alt="图2 工程创建完成"><br>在工程界面，选择左边IP INTEGRATOR下的create block design。再点击diagram下的“+”，在弹出的选择框中，输入zynq，如图3所示，双击该选项，得到如图4所示的，最初始的PS。<br><img src="https://s1.ax1x.com/2022/07/16/j5yzi8.md.png" alt="图3 选择PS"><br><img src="https://s1.ax1x.com/2022/07/16/j56pRg.md.png" alt="图4 初始化PS"><br>由于本例程只使用了SD卡的读写以及UART，并没有涉及到其他接口，因此需要对该PS进行设置。<br>DDR3的设置，选择适配自己的DDR型号<br><img src="https://s1.ax1x.com/2022/07/16/j56FLn.md.png" alt="图5 DDR3设置"><br>时钟的设置<br><img src="https://s1.ax1x.com/2022/07/16/j56iss.md.png" alt="图6 时钟设置"><br>IO选择，由于例程只用到SD以及UART，因此只勾选SD和UART的引脚，注意BANK1为1.8V<br><img src="https://s1.ax1x.com/2022/07/16/j56AZq.md.png" alt="图7 IO的选择"><br>串口的设置<br><img src="https://s1.ax1x.com/2022/07/16/j56Ed0.md.png" alt="图8 串口设置"><br>复位去除<br><img src="https://s1.ax1x.com/2022/07/16/j56VoV.md.png" alt="图9 复位去除"><br>设置完成后点击run block automation，创建自己的IP核，最后如10所示.<br><img src="https://s1.ax1x.com/2022/07/16/j56eiT.md.png" alt="图10 设置完成后的IP核"><br>之后右击工程，选择generate output products,如图11所示。<br><img src="https://s1.ax1x.com/2022/07/16/j56mJU.png" alt="图11 生成输出文件"><br>之后右击工程，生成HDL wrapper后，选择file-&gt;export hardware，该处不点击生成比特流文件，因为并没有用到PL的部分。<br>在完成以上操作后，硬件环境搭建完成，进入SDK进行编写。</p><h1 id="SDK库文件添加"><a href="#SDK库文件添加" class="headerlink" title="SDK库文件添加"></a>SDK库文件添加</h1><p>此处操作主要添加板载支持文件——FAT32文件系统.<br>在打开的SDK页面，选择file—&gt;new—&gt;application project.填好工程名后，选择空工程。<br>之后右击选择board support package settings,如图12.<br><img src="https://s1.ax1x.com/2022/07/16/j56nWF.md.png" alt="图12 板载支持包设置"><br>勾选xilffs文件即完成FAT32系统支持包的添加。</p><h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>本例程完成SD卡的读写以及通过串口打印是否读写正确。程序代码如下：</p><pre class="line-numbers language-none"><code class="language-none">#include "xil_printf.h"#include "ff.h"#include "xparameters.h"#define file_name "example.txt"char str_wr[50]="1315";//将wr_data[]中数据写入wr_len个void sd_write_data(char wr_data[],u32 wr_len){FIL file;UINT bw;f_open(&amp;file,file_name,FA_CREATE_ALWAYS|FA_WRITE|FA_READ);//打开（创建）文件f_lseek(&amp;file,0);//移动读写指针f_write(&amp;file,wr_data,wr_len,&amp;bw);//写数据f_close(&amp;file);//关闭文件}//读出rd_len个数据到rd_data中void sd_read_data(char rd_data[],u32 rd_len){FIL file;UINT br;f_open(&amp;file,file_name,FA_READ);//打开文件f_lseek(&amp;file,0);//移动读写指针f_read(&amp;file,rd_data,rd_len,&amp;br);//写数据f_close(&amp;file);//关闭文件}//将SD卡格式化void sd_mount(){    FRESULT state;FATFS fs;    BYTE work[FF_MAX_SS];    state=f_mount(&amp;fs,"",1);    if(state!=FR_OK)    {    xil_printf("not fat32");    //格式化SD卡    f_mkfs("",FM_FAT32,0,work,sizeof work);    state=f_mount(&amp;fs,"",1);    }}int main(){FATFS fs;u32 len=0;char str_rd[50]="";f_mount(&amp;fs,"",1);//进行挂载len=strlen(str_wr);sd_write_data(str_wr,len);//写入数据    sd_read_data(str_rd,len);//读取数据    if(strcmp(str_wr,str_rd)==0) xil_printf("succeed!!\r\n");    else xil_printf("fail!!!\r\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ZYNQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式基础通信之SPI</title>
      <link href="/2022/03/20/qian-ru-shi-ji-chu-tong-xin-zhi-spi/"/>
      <url>/2022/03/20/qian-ru-shi-ji-chu-tong-xin-zhi-spi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SPI简介"><a href="#1-SPI简介" class="headerlink" title="1 SPI简介"></a>1 SPI简介</h1><p> SPI(Serial Peripheral interface)是一种同步串行总线的通信方式，常用于EEPROM，FLASH，ADC等外围器件。该通信具有高速、全双工的特点。同时该通信仅需4个接口，节约芯片管脚，在PCB布局上能够大大节省空间。因其优良的特性，应用也越来越广泛。<br> SPI的接口主要包含：<br> MISO：master in slave out,主进从出，即主设备数据输入，从设备数据输出。<br> MOSI：master out slave in,主出从进，即主设备数据输出，从设备数据输入。<br> SCLK：时钟信号线，由主设备产生，用于数据交换时的时序。<br> CS：从设备片选信号，由主设备控制。</p><h1 id="2-SPI工作方式与时序分析"><a href="#2-SPI工作方式与时序分析" class="headerlink" title="2 SPI工作方式与时序分析"></a>2 SPI工作方式与时序分析</h1><p> SPI总共有四种工作方式，根据外设以及使用需求进行合理的设置。<br> 主要为时钟极性(CPOL)以及时钟相位(CPHA)。<br> 对于时钟极性：</p><pre class="line-numbers language-none"><code class="language-none">CPOL=1：串行同步时钟的空闲状态为高电平，即空闲状态SCLK=1.CPOL=0：串行同步时钟的空闲状态为低电平，即空闲状态SCLK=0.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 对于时钟相位：<br> </p><pre class="line-numbers language-none"><code class="language-none">CPHA=1：串行同步时钟的第二个跳变沿数据被采样。CPHA=0：串行同步时钟的第一个跳变沿数据被采样。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br> CPHA=1比CPHA=0时，数据采样延时了一个时钟。<br>CPHA不同时，其时序图分别如图1，图2所示：<br><img src="https://s1.ax1x.com/2022/07/18/jobq3Q.md.png" alt="图1 CPHA=0时SPI数据传输时序"><br><img src="https://s1.ax1x.com/2022/07/18/jobb9g.md.png" alt="图2 CPHA=1时SPI数据传输时序"><p></p><h1 id="3-程序代码"><a href="#3-程序代码" class="headerlink" title="3 程序代码"></a>3 程序代码</h1><p>本程序采用笔者在进行Lora项目开发时，ASR6505模块中stm8与sx1262进行SPI数据交互的底层驱动。参考了Semtech代码。<br>主要程序如下，该SPI通信采用软件控制CS。</p><pre class="line-numbers language-none"><code class="language-none">void SpiInit( Spi_t *obj, SpiId_t spiId, PinNames mosi, PinNames miso, PinNames sclk, PinNames nss ){    SPI_TypeDef *spix = SPI1;    if(SpiInitialized)        return;        BoardDisableIrq( );    obj-&gt;SpiId = spiId;    if(spiId == SPI_1) {        CLK_PeripheralClockConfig(CLK_Peripheral_SPI1, ENABLE);        spix = SPI1;    }else if(spiId == SPI_2) {        CLK_PeripheralClockConfig(CLK_Peripheral_SPI2, ENABLE);        spix = SPI2;    }    {        mosiIndex = ( 0x01 &lt;&lt; ( mosi &amp; 0x0F ) );        misoIndex = ( 0x01 &lt;&lt; ( miso &amp; 0x0F ) );        sclkIndex = ( 0x01 &lt;&lt; ( sclk &amp; 0x0F ) );        nssIndex = ( 0x01 &lt;&lt; ( nss &amp; 0x0F ) );        if( ( mosi &amp; 0xF0 ) == 0x00 )        {            spi_port = GPIOA;        }        else if( ( mosi &amp; 0xF0 ) == 0x10 )        {            spi_port = GPIOB;        }        else if( ( mosi &amp; 0xF0 ) == 0x20 )        {            spi_port = GPIOC;        }        else if( ( mosi &amp; 0xF0 ) == 0x30 )        {            spi_port = GPIOD;        }        else if( ( mosi &amp; 0xF0 ) == 0x40 )        {            spi_port = GPIOE;        }         else if( ( mosi &amp; 0xF0 ) == 0x50 )        {            spi_port = GPIOF;        }         else if( ( mosi &amp; 0xF0 ) == 0x60 )        {            spi_port = GPIOG;        }        else if( ( mosi &amp; 0xF0 ) == 0x70 )        {            spi_port = GPIOH;        }        else if( ( mosi &amp; 0xF0 ) == 0x80 )        {            spi_port = GPIOI;        }        obj-&gt;Mosi.port = spi_port;        obj-&gt;Miso.port = spi_port;        obj-&gt;Sclk.port = spi_port;        obj-&gt;Mosi.pinIndex = mosiIndex;        obj-&gt;Miso.pinIndex = misoIndex;        obj-&gt;Sclk.pinIndex = sclkIndex;        GPIO_ExternalPullUpConfig(spi_port, mosiIndex | misoIndex | sclkIndex, ENABLE);                /* pin remap */        if(spix==SPI2 &amp;&amp; sclk==PI_1)            SYSCFG_REMAPPinConfig(REMAP_Pin_SPI2Full, ENABLE);        else if(spix==SPI1 &amp;&amp; sclk==PF_2)            SYSCFG_REMAPPinConfig(REMAP_Pin_SPI1PortF, ENABLE);                                SPI_Init(spix, SPI_FirstBit_MSB, SPI_BaudRatePrescaler_32, SPI_Mode_Master,           SPI_CPOL_Low, SPI_CPHA_1Edge, SPI_Direction_2Lines_FullDuplex,           SPI_NSS_Soft, 0x07);        SPI_Cmd(spix, ENABLE);    }        SpiInitialized = true;    BoardEnableIrq( );}void SpiDeInit( Spi_t *obj ){    if(!spi_port || !SpiInitialized)        return;        if(obj-&gt;SpiId == SPI_1) {        SPI_Cmd(SPI1, DISABLE);        SPI_DeInit(SPI1);        CLK_PeripheralClockConfig(CLK_Peripheral_SPI1, DISABLE);    }else if(obj-&gt;SpiId == SPI_2) {        SPI_Cmd(SPI2, DISABLE);        SPI_DeInit(SPI2);        CLK_PeripheralClockConfig(CLK_Peripheral_SPI2, DISABLE);    }         GPIO_ExternalPullUpConfig(spi_port, mosiIndex | misoIndex | sclkIndex, DISABLE);    GPIO_Init(obj-&gt;Nss.port, obj-&gt;Nss.pinIndex, GPIO_Mode_Out_PP_High_Fast);        GPIO_Init(spi_port, sclkIndex, GPIO_Mode_In_PU_No_IT);    GPIO_Init(spi_port, misoIndex, GPIO_Mode_In_PU_No_IT);    GPIO_Init(spi_port, mosiIndex, GPIO_Mode_In_PU_No_IT);         SpiInitialized = false;}void SpiFormat( Spi_t *obj, int8_t bits, int8_t cpol, int8_t cpha, int8_t slave ){    }void SpiFrequency( Spi_t *obj, uint32_t hz ){    }uint16_t SpiInOut( Spi_t *obj, uint16_t outData ){    SPI_TypeDef *spix = obj-&gt;SpiId==SPI_1?SPI1:SPI2;    uint8_t rxData = 0;    BoardDisableIrq( );    /* Loop while DR register in not emplty */    while (SPI_GetFlagStatus(spix, SPI_FLAG_TXE) == RESET);        /* Send byte through the SPI peripheral */    SPI_SendData(spix, outData);        /* Wait to receive a byte */    while (SPI_GetFlagStatus(spix, SPI_FLAG_RXNE) == RESET);        /* Return the byte read from the SPI bus */    rxData = SPI_ReceiveData(spix);    BoardEnableIrq( );    return( rxData );}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式基础通信之IIC</title>
      <link href="/2022/03/16/qian-ru-shi-ji-chu-tong-xin-zhi-iic/"/>
      <url>/2022/03/16/qian-ru-shi-ji-chu-tong-xin-zhi-iic/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IIC简介"><a href="#1-IIC简介" class="headerlink" title="1 IIC简介"></a>1 IIC简介</h1><p>IIC(Inter－Integrated Circuit)是由飞利浦公司开发的两线式串行通信方式，主要用于微控制器与外围设备之间的通信。其传输数据量较小，且传输距离较短，在同一时刻只能有一个主机。由于IIC是为了与低速设备通信而发明的，因此IIC的传输速率低，不及SPI等通信方式。但高速 IIC 总线一般也可达400kbps 以上。</p><h1 id="2-IIC时序分析"><a href="#2-IIC时序分析" class="headerlink" title="2 IIC时序分析"></a>2 IIC时序分析</h1><p>IIC由两条总线组成，分别是双向的数据传输线SDA以及串行时钟线SCL。<br>在IIC传输数据的过程中，总共有三种类型的信号，分别是开始信号，结束信号以及应答信号。下面对这三种信号进行分析。<br>首先是开始信号，该信号开始的标志为SCL为高电平时，SDA由高电平转向低电平，数据开始传输。<br>之后是结束信号，该信号结束的标志为SCL为高电平时，SDA由低电平转向高电平，数据结束传输。<br><strong>结束信号与开始信号的SDA变化刚好相反</strong><br><strong>由于开始信号要求SCL为高电平，因此IIC通信SCL与SDA需要接上拉电阻，保持初始状态都为高电平</strong><br><strong>目前有些器件IIC已经内置上拉电阻，因此是否接上拉电阻酌情考虑</strong><br>对于应答信号，则是在接收数据的IC接收到8bit数据后向发送数据的IC发送特定的低电平脉冲，表示已收到数据。IIC总线时序图如图1所示<br><img src="https://s1.ax1x.com/2022/07/18/jo7cVK.md.png" alt="图1 IIC总线时序图"><br>对于IIC数据传输过程，其时序图如图2所示。<br><img src="https://s1.ax1x.com/2022/07/18/jo725D.md.jpg" alt="图2 IIC数据传输过程"></p><h1 id="3-程序代码"><a href="#3-程序代码" class="headerlink" title="3 程序代码"></a>3 程序代码</h1><p>目前许多MCU都已集成硬件IIC，直接进行相应设置即可。但考虑到移植的兼容性以及加深个人对IIC的理解，程序采用通用IO模拟IIC。参考正点原子的例程，下面给出了IO口模拟IIC的程序。</p><pre class="line-numbers language-none"><code class="language-none">//初始化IICvoid IIC_Init(void){     GPIO_InitTypeDef GPIO_InitStructure;RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE );//使能GPIOB时钟   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP ;   //推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOB, &amp;GPIO_InitStructure);GPIO_SetBits(GPIOB,GPIO_Pin_6|GPIO_Pin_7); //PB6,PB7 输出高}//产生IIC起始信号void IIC_Start(void){SDA_OUT();     //sda线输出IIC_SDA=1;    IIC_SCL=1;delay_us(4); IIC_SDA=0;//START:when CLK is high,DATA change form high to low delay_us(4);IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 }  //产生IIC停止信号void IIC_Stop(void){SDA_OUT();//sda线输出IIC_SCL=0;IIC_SDA=0;//STOP:when CLK is high DATA change form low to high delay_us(4);IIC_SCL=1; IIC_SDA=1;//发送I2C总线结束信号delay_us(4);   }//等待应答信号到来//返回值：1，接收应答失败//        0，接收应答成功u8 IIC_Wait_Ack(void){u8 ucErrTime=0;SDA_IN();      //SDA设置为输入  IIC_SDA=1;delay_us(1);   IIC_SCL=1;delay_us(1); while(READ_SDA){ucErrTime++;if(ucErrTime&gt;250){IIC_Stop();return 1;}}IIC_SCL=0;//时钟输出0    return 0;  } //产生ACK应答void IIC_Ack(void){IIC_SCL=0;SDA_OUT();IIC_SDA=0;delay_us(2);IIC_SCL=1;delay_us(2);IIC_SCL=0;}//不产生ACK应答    void IIC_NAck(void){IIC_SCL=0;SDA_OUT();IIC_SDA=1;delay_us(2);IIC_SCL=1;delay_us(2);IIC_SCL=0;}      //IIC发送一个字节//返回从机有无应答//1，有应答//0，无应答  void IIC_Send_Byte(u8 txd){                            u8 t;   SDA_OUT();         IIC_SCL=0;//拉低时钟开始数据传输    for(t=0;t&lt;8;t++)    {                      //IIC_SDA=(txd&amp;0x80)&gt;&gt;7;if((txd&amp;0x80)&gt;&gt;7)IIC_SDA=1;elseIIC_SDA=0;txd&lt;&lt;=1;   delay_us(2);   //对TEA5767这三个延时都是必须的IIC_SCL=1;delay_us(2); IIC_SCL=0;delay_us(2);    } }     //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   u8 IIC_Read_Byte(unsigned char ack){unsigned char i,receive=0;SDA_IN();//SDA设置为输入    for(i=0;i&lt;8;i++ ){        IIC_SCL=0;         delay_us(2);IIC_SCL=1;        receive&lt;&lt;=1;        if(READ_SDA)receive++;   delay_us(1);     }     if (!ack)        IIC_NAck();//发送nACK    else        IIC_Ack(); //发送ACK       return receive;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式基础通信之红外通信-R05d协议</title>
      <link href="/2022/03/15/qian-ru-shi-ji-chu-tong-xin-zhi-hong-wai-tong-xin/"/>
      <url>/2022/03/15/qian-ru-shi-ji-chu-tong-xin-zhi-hong-wai-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="1-硬件基础"><a href="#1-硬件基础" class="headerlink" title="1 硬件基础"></a>1 硬件基础</h1><p> 红外通信一般包含红外发射电路以及红外接收电路两部分。红外发射电路主要将二进制信号通过脉宽调制的方式以红外光的形式发射出去；红外接收电路对接收到的红外信号进行解调从而实现红外通信。</p><h2 id="1-1-红外发射电路"><a href="#1-1-红外发射电路" class="headerlink" title="1.1 红外发射电路"></a>1.1 红外发射电路</h2><p> 红外通信的距离以及抗干扰强度与其功率有关，因此为保证红外通信距离一般采用mos管作为功率开关，对其进行功率放大。设计电路如图1<br> <img src="https://s1.ax1x.com/2022/07/16/j5Vv4J.jpg" alt="图1 红外发射电路"><br> 该电路采用mos管通过对电流进行放大增加红外功率，笔者也对三极管通过电压放大增加功率的方式进行过实验，其效果不如电流放大的形式。在电路外围并联电容存储能量，防止在进行红外通信时因为频率过快，电能供应不及时而导致通信效果不佳。</p><h2 id="1-2-红外接收电路"><a href="#1-2-红外接收电路" class="headerlink" title="1.2 红外接收电路"></a>1.2 红外接收电路</h2><p> 红外接收电路对红外信号进行接收、放大、检波、整形并最后解调出二进制脉冲，从而完成红外通信。因笔者对接收电路原理了解不多，直接采购淘宝的接收模块，因此对接收电路不做评述。</p><h1 id="2-R05d协议介绍"><a href="#2-R05d协议介绍" class="headerlink" title="2 R05d协议介绍"></a>2 R05d协议介绍</h1><p>  R05d协议为美的空调红外通信协议，其编码与时序与NEC不同，下面以编码和时序两部分对其进行详细介绍。</p><h2 id="2-1-R05d协议编码"><a href="#2-1-R05d协议编码" class="headerlink" title="2.1 R05d协议编码"></a>2.1 R05d协议编码</h2><p>  R05d通常编码形式为LAA’BB’CC’SLAA’BB’CC’(部分协议尾部还会加一个结束码)。<br>  L为引导码；S为分隔码，用于区分第一帧与第二帧；<br>  A为识别码，一般采用A=0xB2，预留A=0xB7，A’为A的反码；B用于控制空调风速，B’为B的反码；C用于控制温度以及模式，C’为C的反码。<br>  下面是B各值代表的含义<br>  <img src="https://s1.ax1x.com/2022/07/16/j5ZS3R.png" alt="图2 B-参数表"><br>  下面是C各值代表的含义<br>  <img src="https://s1.ax1x.com/2022/07/16/j5Zpg1.png" alt="图3 C-参数表"><br>  ==注意：各编码都为高位先发==</p><h2 id="2-2-R05d协议时序"><a href="#2-2-R05d协议时序" class="headerlink" title="2.2 R05d协议时序"></a>2.2 R05d协议时序</h2><p>  下面主要对引导码，分隔码，“0”数据，“1”数据以及终止符进行时序讲解。<br>  <strong>发送引导码</strong><br>  <img src="https://s1.ax1x.com/2022/07/16/j5VLHU.png" alt="图4 引导码时序"><br>  <strong>发送分隔码</strong><br>  <img src="https://s1.ax1x.com/2022/07/16/j5VXEF.png" alt="图5 分隔码时序"><br>  <strong>发送“0”数据</strong><br>  <img src="https://s1.ax1x.com/2022/07/16/j5VqBT.png" alt="图6 “0”数据时序"><br>  <strong>发送“1”数据</strong><br>  <img src="https://s1.ax1x.com/2022/07/16/j5VjN4.png" alt="图7 “1”数据时序"><br>  <strong>发送终止符</strong><br>  <img src="https://s1.ax1x.com/2022/07/16/j5VzC9.png" alt="图8 终止符时序"><br>==各时序时间不要求完全相等，可以存在一定的误差==</p><h1 id="3-程序代码"><a href="#3-程序代码" class="headerlink" title="3 程序代码"></a>3 程序代码</h1><p>  本程序采用stm32进行编写，以通用IO进行控制，对于定时器资源不足的情况具有较好的适应性。</p><pre class="line-numbers language-none"><code class="language-none">//红外通信 R05D电控协议void IR_Init(){   GPIO_InitTypeDef  GPIO_InitStructure;   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;  //PC11   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //IO速度为50MHz   GPIO_Init(GPIOC, &amp;GPIO_InitStructure);  //初始化GPIOA.15   GPIO_ResetBits(GPIOC,GPIO_Pin_11);}//38KHz 发送载波 高电平 1/38KHz=26.3us 高点26.3/3=8.77us 低电17.53us//a-----发送载波周期数//发射0-----a=21  0.54ms/26.14us=20.658 //发射1-----a=62  1.62ms/26.14us=61.974//发射S-----a=200 5.22ms/26.14us=199.693   //201//发射L-----a=168 4.4ms/26.14us=168.324    //169void Send_IR(u32 a){while(a--){    IR=1;  delay_us(8);  IR=0;  delay_us(17);}}//38KHz 不发送载波 低电平//发射0-----a=21  0.54ms/26.15us=20.65//发射1-----a=21  0.54ms/26.15us=20.65//发射S-----a=21  0.54ms/26.15us=20.65//发射L-----a=168 4.4ms/26.15us=168.26   //169void No_Send_IR(u32 a){   while(a--) {   IR=0;   delay_us(26); }}//发射1void Send_h(){ Send_IR(21); No_Send_IR(61);}//发射0void Send_l(){   Send_IR(21);   No_Send_IR(20);}//发射L 引导码void Send_L(){ Send_IR(168); No_Send_IR(168);}//发射S 分隔码void Send_S(){   Send_IR(21);   No_Send_IR(201);}//发射终止符void Send_End(){   Send_IR(21);//0.54ms低(接收端)  高(发送端)}//一般情况编码方式 A' B' C'分别为ABC的反码，L引导码，S分隔码，A识别码(A=10110010=0xB2，预留方案时A=10110111=0xB7)//LAA'BB'CC' S LAA'BB'CC'//高位先发，用于分析时序//B各位 bit7-bit5 风速 bit4-bit0 默认为1//C各位 bit7-bit4 温度 bit3-bit2 模式 10-自动  bit1-bit0 00//      0000-17度                    00-制冷//      0001-18                      11-制热//      0011-19度                    01-抽风/送湿//      0010-20 //2//      0110-21 //6//      0111-22 //7//      0101-23 //5//      0100-24 //4//      1100-25 //c//      1101-26 //d//      1001-27 //9//      1000-28 //8//      1010-29 //a//      1011-30 //bvoid Send_Message(u8 A,u8 B,u8 C){  u8 temp; int i;   Send_L(); temp=A; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~A; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }  temp=B; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~B; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }  temp=C; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~C; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }    Send_S();   Send_L(); temp=A; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~A; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }  temp=B; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~B; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }  temp=C; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  } temp=~C; for(i=0;i&lt;8;i++) {   if(temp&amp;0x80) Send_h(); else Send_l();temp=temp&lt;&lt;1;  }   Send_S(); Send_L(); Send_Unknow();   Send_End(); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-实验分析"><a href="#4-实验分析" class="headerlink" title="4 实验分析"></a>4 实验分析</h1><p>通过stm32控制红外发射管将调制后的红外信号发送，以红外接收管对数据进行接收，通过示波器测量红外接收管接收到的信号，对通信数据正确性进行验证。<br>下面是通过示波器采集到的红外接收管上传出的部分信号：<br><img src="https://s1.ax1x.com/2022/07/16/j5Z9jx.png" alt="采集信号"><br><img src="https://s1.ax1x.com/2022/07/16/j5ZiDK.png" alt="采集信号"><br><img src="https://s1.ax1x.com/2022/07/16/j5ZPu6.png" alt="采集信号"><br>通过对空调进行控制，能完美控制空调。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS基础（一）</title>
      <link href="/2021/08/16/freertos-ji-chu-yi/"/>
      <url>/2021/08/16/freertos-ji-chu-yi/</url>
      
        <content type="html"><![CDATA[<p>本篇主要对FreeRTOS的任务与中断进行初步讲解记录</p><h1 id="1-FreeRTOS任务"><a href="#1-FreeRTOS任务" class="headerlink" title="1 FreeRTOS任务"></a>1 FreeRTOS任务</h1><h2 id="1-1-任务状态"><a href="#1-1-任务状态" class="headerlink" title="1.1 任务状态"></a>1.1 任务状态</h2><p>对于FreeRTOS来说，任务主要分为4种状态。分别为运行态，就绪态，阻塞态以及挂起态。</p><pre class="line-numbers language-none"><code class="language-none">&gt; 运行态：正在运行&gt; 就绪态：可以运行，等待调度器调度&gt; 阻塞态：等待某一个事件到来后可就绪&gt; 挂起态：退出调度系统，无法调度运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>任务的四种状态之间可以互相转换，他们的关系可以见下图1:<br><img src="https://s1.ax1x.com/2022/07/17/j5bGTO.md.jpg" alt="图1 FreeRTOS各任务状态关系"></p><h2 id="1-2-任务优先级与任务实现"><a href="#1-2-任务优先级与任务实现" class="headerlink" title="1.2 任务优先级与任务实现"></a>1.2 任务优先级与任务实现</h2><p>在FreeRTOS中，任务优先级在FreeRTOSConfig.h文件进行了宏定义。<br><code>#define configMAX_PRIORITIES          (32)</code><br>在该定义中优先级的级数范围为0~31（configMAX_PRIORITIES-1），数字越大代表优先级的级数越高。其中定时器默认为最高优先级， 空闲任务优先级默认为0.</p><h3 id="1-2-1-任务的创建与删除"><a href="#1-2-1-任务的创建与删除" class="headerlink" title="1.2.1 任务的创建与删除"></a>1.2.1 任务的创建与删除</h3><p>在了解任务优先级后，接下来对任务进行创建和删除。任务的创建包含三种形式，分别是动态创建、静态创建以及MPU创建。一般来说， 对于用户自定义的任务主要采取动态创建以及静态创建的方式，两者区别在于动态创建由系统分配堆栈，而静态创建则是由用户自己传递。</p><p>首先我们用动态的方法进行任务的创建，需要用到xTaskCreate()这个函数。 xTaskCreate()格式如下：</p><pre class="line-numbers language-none"><code class="language-none">xTaskCreate(              函数名，             任务名，             任务堆栈大小，             传递给任务函数参数，             任务优先级，             任务句柄            );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体使用的例子：创建任务名为task1_task的任务</p><pre class="line-numbers language-none"><code class="language-none">xTaskCreate((TaskFunction_t )task1_task,                        (const char*    )"task1_task",                      (uint16_t       )TASK1_STK_SIZE, //TASK1_STK_SIZE可在程序开头宏定义             (void*          )NULL,                             (UBaseType_t    )TASK1_TASK_PRIO,                   (TaskHandle_t*  )&amp;Task1Task_Handler); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于静态创建任务的方法设置比动态创建任务更加繁杂，首先需要在FreeRTOSConfig.h文件中添加静态创建允许的宏并将其打开。<br><code>#define configSUPPORT_STATIC_ALLOCATION        1  </code><br>同时在tasks.c文件中空闲任务函数vApplicationGetIdleTaskMemory()以及timers.c文件中定时器函数vApplicationGettimerTaskMemory()需要重新定义赋值</p><p>空闲任务函数</p><pre class="line-numbers language-none"><code class="language-none">static StaticTask_t IdleTaskTCB;                                         //定义任务控制块static StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];              //定义堆栈名和大小void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, //任务控制块                                    StackType_t **ppxIdleTaskStackBuffer,//任务堆栈                                     uint32_t *pulIdleTaskStackSize )     //堆栈大小     {        *ppxIdleTaskTCBBuffer=&amp;IdleTaskTCB;        *ppxIdleTaskStackBuffer=IdleTaskStack;        *pulIdleTaskStackSize=configMINIMAL_STACK_SIZE;     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定时器函数</p><pre class="line-numbers language-none"><code class="language-none">static StaticTask_t TimerTaskTCB;                                         static StackType_t TimerTaskStack[configTIMER_TASK_STACK_DEPTH];void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,                                     StackType_t **ppxTimerTaskStackBuffer,                                     uint32_t *pulTimerTaskStackSize )     {        *ppxTimerTaskTCBBuffer=&amp;TimerTaskTCB;        *ppxTimerTaskStackBuffer=TimerTaskStack;        *pulTimerTaskStackSize=configTIMER_TASK_STACK_DEPTH;     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当这两个函数重新定义完成后，可以进行静态任务的创建，使用函数xTaskCreateStatic() xTaskCreateStatic()格式如下：</p><pre class="line-numbers language-none"><code class="language-none">任务句柄=xTaskCreateStatic(                           函数名,                           任务名,                           任务堆栈大小,                           传递给任务函数参数,                           任务优先级,                           任务堆栈,                           任务控制块                          );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面，我们通过这种方式创建任务名为task1_task的任务</p><pre class="line-numbers language-none"><code class="language-none">Task1Task_Handler=xTaskCreateStatic((TaskFunction_t)task1_task,                                    (const char*   )"task1_task",                                    (uint32_t      )TASK1_STK_SIZE,                                    (void*         )NULL,                                    (UBaseType_t   )TASK1_TASK_PRIO,                                    (StackType_t*  )Task1TaskStack,                                    (StaticTask_t* )&amp;Task1TaskTCB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以上两种方式，在任务创建完成后，开启任务调度器则可以根据任务优先级进行任务的执行。<br><code>vTaskStartScheduler();//任务调度器开启</code><br>若想将任务移除，只需使用vTaskDelete()函数，其格式为：<br><code>vTaskDelete(任务句柄);</code><br>比如将上面创建的task1_task删除，因为创建任务时赋予的任务句柄为Task1Task_Handler，因此删除任务为：<br><code>vTaskDelete(Task1Task_Handler);</code></p><h3 id="1-2-2-任务的挂起与恢复"><a href="#1-2-2-任务的挂起与恢复" class="headerlink" title="1.2.2 任务的挂起与恢复"></a>1.2.2 任务的挂起与恢复</h3><p>首先对这两个概念进行解释：</p><pre class="line-numbers language-none"><code class="language-none">&gt;挂起：暂停某任务运行&gt;恢复：让暂停的任务恢复运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于任务的挂起与恢复主要用到三个函数，分别为：</p><pre class="line-numbers language-none"><code class="language-none">vTaskSuspend(任务句柄);       //任务挂起vTaskResume(任务句柄);        //任务恢复xTaskResumeFormISR(任务句柄); //中断服务函数中恢复一个任务的运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前两个函数直接使用即可，对于最后一个函数的使用，首先需要在FreeRTOSconfig.h文件中设置宏<br><code>#define INCLUDE_xTaskResumeFromISR         1</code><br>在使用xTaskResumeFormISR()时，会产生一个返回值，若返回值为pdtrue，则代表恢复的任务优先级比当前运行任务的优先级要高，需要进行任务切换。若返回值为pdfalse，则代表恢复的任务优先级比当前运行任务的优先级低，不需要进行任务切换。</p><h1 id="FreeRTOS中断"><a href="#FreeRTOS中断" class="headerlink" title="FreeRTOS中断"></a>FreeRTOS中断</h1><h2 id="2-1-中断分组及优先级概述"><a href="#2-1-中断分组及优先级概述" class="headerlink" title="2.1 中断分组及优先级概述"></a>2.1 中断分组及优先级概述</h2><p>由于不同内核的芯片，其内部硬件结构不同，因而对于中断管理存在一定差异。本文以stm32为基础对其中断管理进行分析。 stm32是基于cortex-M系列的一款芯片，其中断由中断寄存器NVIC进行管理。在中断向量表中，编号为1-15的是系统异常中断，大于15的为外部中断。在系统中断中我们主要关心pendsv以及systick。</p><p>在cortex-M3系列中，各中断的优先级由其对应的中断优先级寄存器进行管理。stm32在优先级分组中分出了抢占优先级以及亚优先级的位段，分别为4-7位抢占优先级，5-7位的抢占优先级，6-7位的抢占优先级，7-7位的抢占优先级以及所有位作为亚优先级，共5组的优先级分组。</p><p>比如在4-7位的抢占优先级分组中，优先级共有2^4=16级，最高优先级则为0，最低为15</p><p>对于外部中断，在stm32中设置优先级需在中断向量表中找到对应的IP寄存器位数后进行设置。而对于系统异常则不一样，下面对pendsv以及systick的设置进行探究。 我们将这两个设为最低优先级。 在FreeRTOS中设置pendsv以及systick的优先级在port.c文件中。</p><pre class="line-numbers language-none"><code class="language-none">#define portNVIC_PENDSV_PRI    ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL )#define portNVIC_SYSTICK_PRI   ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL )portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;    //给pendsv写入portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;   //给systick写入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在FreeRTOSconfig.h中又有定义</p><pre class="line-numbers language-none"><code class="language-none">#ifdef __NVIC_PRIO_BITS  #define configPRIO_BITS       __NVIC_PRIO_BITS#else  #define configPRIO_BITS       4                  #endif#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY  15  //最低优先级#define configKERNEL_INTERRUPT_PRIORITY    ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中__NVIC_PRIO_BITS为定义的优先级分组。通过以上的设置pendsv以及systick被设置为了最低优先级。</p><h2 id="2-2-中断屏蔽"><a href="#2-2-中断屏蔽" class="headerlink" title="2.2 中断屏蔽"></a>2.2 中断屏蔽</h2><p>在cortex-M3中提供了3个寄存器以实现中断屏蔽，分别为PRIMASK,FAULTMASK以及BASEPRI。<br>PRIMASK：除FAULT与NMI都可进行管理。<br>基本操作为：</p><pre class="line-numbers language-none"><code class="language-none">//关中断Mov R0, #1MSR PRIMASK, R0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>快速指令</p><pre class="line-numbers language-none"><code class="language-none">CPSID i   ;//关中断CPSIE i   ;//开中断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>FAULTMASK:可屏蔽FAULT，使用方式与PRIMASK类似。</p><p>BASEPRI：屏蔽优先级低于x的所有中断，x为写入BASEPRI的值。</p><p>在FreeRTOS中只能对优先级为5-15的进行控制，优先级低于5则不能屏蔽。</p><p>关闭中断与开启中断函数如下</p><pre class="line-numbers language-none"><code class="language-none">portdisable_interrupts(); //关中断portenable_interrupts();  //开中断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
